# Autoware Planning Simulator Test

# Default recipe (show help)
default:
    @just --list

# Variables
script_dir := justfile_directory()
autoware_link := script_dir / "autoware"
map_path := env_var_or_default('MAP_PATH', env_var('HOME') / 'autoware_map/sample-map-planning')

# Verify Autoware installation
check-autoware:
    #!/usr/bin/env bash
    set -e
    if [ ! -L "{{autoware_link}}" ]; then
        echo "ERROR: 'autoware' symlink not found"
        echo "Create symlink: ln -s /path/to/autoware autoware"
        exit 1
    fi
    AUTOWARE_PATH=$(readlink -f "{{autoware_link}}" 2>/dev/null)
    if [ -z "$AUTOWARE_PATH" ] || [ ! -d "$AUTOWARE_PATH" ]; then
        echo "ERROR: autoware symlink points to invalid path"
        exit 1
    fi
    if [ ! -f "$AUTOWARE_PATH/install/setup.bash" ]; then
        echo "ERROR: install/setup.bash not found"
        exit 1
    fi

# Run Autoware simulator with play_launch (foreground, Ctrl-C to stop)
run-sim: check-autoware
    #!/usr/bin/env bash
    set -e
    SCRIPT_DIR="{{script_dir}}"
    cd "$SCRIPT_DIR"

    MAP_PATH="{{map_path}}"

    if [ ! -f "$SCRIPT_DIR/cyclonedds.xml" ]; then
        echo "ERROR: CycloneDDS configuration file not found at $SCRIPT_DIR/cyclonedds.xml"
        exit 1
    fi

    # Source ROS and Autoware setup
    source ../../install/setup.bash
    source autoware/install/setup.bash
    export CYCLONEDDS_URI="file://$SCRIPT_DIR/cyclonedds.xml"

    # Run with play_launch
    play_launch launch \
        --web-addr 0.0.0.0:8080 \
        autoware_launch planning_simulator.launch.xml \
        map_path:="$MAP_PATH"

# Run Autoware demo (simulator + autonomous test) using GNU Parallel
run-demo: check-autoware
    #!/usr/bin/env bash
    set -e
    SCRIPT_DIR="{{script_dir}}"
    cd "$SCRIPT_DIR"

    MAP_PATH="{{map_path}}"
    AUTOWARE_PATH=$(readlink -f autoware)

    if [ ! -f "$SCRIPT_DIR/cyclonedds.xml" ]; then
        echo "ERROR: CycloneDDS configuration file not found at $SCRIPT_DIR/cyclonedds.xml"
        exit 1
    fi

    # Check for GNU Parallel
    if ! command -v parallel &> /dev/null; then
        echo "ERROR: GNU Parallel not found. Install with: sudo apt install parallel"
        exit 1
    fi

    # Source ROS and Autoware setup
    source "$AUTOWARE_PATH/install/setup.bash"
    source "$SCRIPT_DIR/../../install/setup.bash"
    export CYCLONEDDS_URI="file://$SCRIPT_DIR/cyclonedds.xml"

    # Export variables for parallel to inherit
    export MAP_PATH
    export CYCLONEDDS_URI
    export SCRIPT_DIR

    # Run simulator and test in parallel
    # Simulator runs continuously, test waits 60s then runs
    parallel --line-buffer ::: \
        "play_launch launch --web-addr 0.0.0.0:8080 autoware_launch planning_simulator.launch.xml map_path:=\"$MAP_PATH\"" \
        "sleep 60 && python3 $SCRIPT_DIR/scripts/test_autonomous_drive.py && echo '[Demo] Test completed. Press Ctrl-C to stop simulator.'"

# Generate resource usage plots from latest play_log
plot:
    @play_launch plot

# Dump launch file using Rust parser
dump-rust: check-autoware
    #!/usr/bin/env bash
    set -e
    SCRIPT_DIR="{{script_dir}}"
    cd "$SCRIPT_DIR"

    MAP_PATH="{{map_path}}"

    # Source ROS and Autoware setup
    source ../../install/setup.bash
    source autoware/install/setup.bash

    echo "Dumping with Rust parser..."
    play_launch dump --output record_rust.json launch \
        --parser rust \
        autoware_launch planning_simulator.launch.xml \
        map_path:="$MAP_PATH"

    echo "✓ Rust parser dump complete: record_rust.json"

# Dump launch file using Python parser
dump-python: check-autoware
    #!/usr/bin/env bash
    set -e
    SCRIPT_DIR="{{script_dir}}"
    cd "$SCRIPT_DIR"

    MAP_PATH="{{map_path}}"

    # Source ROS and Autoware setup
    source ../../install/setup.bash
    source autoware/install/setup.bash

    echo "Dumping with Python parser..."
    play_launch dump --output record_python.json launch \
        --parser python \
        autoware_launch planning_simulator.launch.xml \
        map_path:="$MAP_PATH"

    echo "✓ Python parser dump complete: record_python.json"

# Dump with both parsers
dump-both: dump-rust dump-python

# Compare Rust and Python parser outputs
compare-dumps:
    #!/usr/bin/env bash
    set -e
    SCRIPT_DIR="{{script_dir}}"
    cd "$SCRIPT_DIR"

    if [ ! -f "record_rust.json" ]; then
        echo "ERROR: record_rust.json not found. Run 'just dump-rust' first."
        exit 1
    fi

    if [ ! -f "record_python.json" ]; then
        echo "ERROR: record_python.json not found. Run 'just dump-python' first."
        exit 1
    fi

    echo "Comparing Rust and Python parser outputs..."
    echo ""

    # Use the compare_records.py script from the repo root
    python3 ../../scripts/compare_records.py record_rust.json record_python.json

    echo ""
    echo "Comparison complete."

# Count running processes vs expected (from record.json)
count-processes PARSER="rust": check-autoware
    #!/usr/bin/env bash
    set -e
    SCRIPT_DIR="{{script_dir}}"
    cd "$SCRIPT_DIR"

    MAP_PATH="{{map_path}}"
    PARSER="{{PARSER}}"

    # Source ROS and Autoware setup
    source ../../install/setup.bash
    source autoware/install/setup.bash
    export CYCLONEDDS_URI="file://$SCRIPT_DIR/cyclonedds.xml"

    # Clean previous play_log
    rm -rf play_log/latest 2>/dev/null || true

    # Dump record.json to get expected counts
    echo "Dumping with $PARSER parser to get expected counts..."
    play_launch dump --output record_count.json launch \
        --parser "$PARSER" \
        autoware_launch planning_simulator.launch.xml \
        map_path:="$MAP_PATH"

    EXPECTED=$(python3 -c "import json; r=json.load(open('record_count.json')); print(len(r.get('node',[])) + len(r.get('container',[])))")
    echo "Expected processes: $EXPECTED"

    # Start play_launch in background
    echo "Starting play_launch with --parser $PARSER..."
    play_launch launch \
        --disable-web-ui \
        --parser "$PARSER" \
        autoware_launch planning_simulator.launch.xml \
        map_path:="$MAP_PATH" &
    PL_PID=$!
    PGID=$(ps -o pgid= -p $PL_PID | tr -d ' ')

    cleanup() {
        echo "Cleaning up (PGID=$PGID)..."
        kill -TERM -$PGID 2>/dev/null || true
        sleep 2
        kill -9 -$PGID 2>/dev/null || true
    }
    trap cleanup EXIT

    # Poll pid files until count stabilizes or timeout (60s)
    PREV_COUNT=0
    STABLE=0
    TIMEOUT=60
    ELAPSED=0
    INTERVAL=2

    echo "Waiting for processes to start (timeout: ${TIMEOUT}s)..."
    while [ $ELAPSED -lt $TIMEOUT ]; do
        sleep $INTERVAL
        ELAPSED=$((ELAPSED + INTERVAL))

        # Count cmdline files (containers don't write pid files, but do write cmdline)
        if [ -d "play_log/latest/node" ]; then
            ACTUAL=$(find play_log/latest/node -name "cmdline" -type f ! -empty 2>/dev/null | wc -l)
        else
            ACTUAL=0
        fi

        echo "  ${ELAPSED}s: $ACTUAL/$EXPECTED processes"

        if [ "$ACTUAL" -eq "$PREV_COUNT" ] && [ "$ACTUAL" -gt 0 ]; then
            STABLE=$((STABLE + 1))
        else
            STABLE=0
        fi
        PREV_COUNT=$ACTUAL

        # Stabilized for 3 consecutive polls
        if [ $STABLE -ge 3 ]; then
            echo "Process count stabilized at $ACTUAL"
            break
        fi

        # Already at expected count — wait one more poll to confirm
        if [ "$ACTUAL" -ge "$EXPECTED" ] && [ $STABLE -ge 1 ]; then
            echo "Reached expected count ($ACTUAL >= $EXPECTED)"
            break
        fi
    done

    echo ""
    set +e
    python3 ../../scripts/count_processes.py record_count.json --play-log-dir play_log/latest
    RESULT=$?
    set -e

    rm -f record_count.json
    exit $RESULT

# Count processes using Rust parser
count-processes-rust: (count-processes "rust")

# Count processes using Python parser
count-processes-python: (count-processes "python")

# Kill orphan ROS nodes
kill-orphans:
    @./scripts/kill_orphan_nodes.sh
